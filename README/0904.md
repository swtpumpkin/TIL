# 모던 웹 서비스의 구성요소
- - -
# Express Middleware
```js
// 미들웨어 = 함수
function helloMiddleware(res, req, next) {
  console.log('hello')
  next()
}

app.use(helloMiddleware)
```
미들웨어는 함수이다.  
응답객체, 요청객체, next객체를 인자로 받는다.  
요청이 일어났을때마다 콘솔을 찍는다.  

## Middleware란?
- 함수, 즉 안에서 어떤 작업이든 가능.
- request 객체, response 객체, next 함수를 인자로 받음
- request 객체, response 객체를 조작해서 기능 구현
- 다음 미들웨어를 동작시키기 위해 next 함수를 인자 없이 호출(여러가지의 미들웨어를 사용하게 되는데 미들웨어를 사용하는 순서가 중요하다. javascript는 읽는 순서가 정해져있기때문에 선언하는 **순서가 중요**하다.)
- 등록된 순서대로 실행됨

## Middleware 사용법
- app.use - 미들웨어를 앱 전체에서 동작하도록 주입하거나
- app.use('/', ***) - 특정 경로에서만 동작하도록 주입
- app.use(middleware1, middleware2, middleware3, ...) - 한 번에 여러 개 주입

## 미들웨어로 하는 일
- 로깅
- HTTP body를 객체로 변환
- 사용자 인증
- 권한 관리(각 컨텐츠의 소유자만 수정 삭제 권한을 주는 관리)
- ...

## 미들웨어를 사용하는 이유?
여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고 **코드를 재사용**하기 위해 미들웨어를 사용하는 것  

## 미들웨어 생태계
- Express resource
- NPM search  

필요한 기능이 있다고 하면 미들웨어를 검색하면 왠만하면 원하는 기능을 미들웨어로 제공하고 있다.  
미들웨어를 사용해서 응답을 웹브라우저에 표출 할 수 있다.  
미들웨어를 만드는 함수에는 미들웨어라고 작명하지 않는다.  

## next?
미들웨어는 req, res에 더해서 next라는 함수를 추가로 인자로 받습니다.   
next 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있습니다.  
만약에 미들웨어가 next 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 되므로 주의하세요!

## 클로저 함수
```js
function makeAdder (x) {
  return function (y) {
    return x+y
  }
}
```
함수가 함수를 호출하는 함수를 클로저함수라고 한다.  

```js
makeAdder2 = x => y => x+y
```
arrow함수 두개를 겹치게 선언하면 클로저 함수처럼 만들 수 있다.  

## 미들웨어 vs 라우트 핸들러
- 라우트 핸들러도 미들웨어
- 즉, next 함수를 인자로 받는 것이 가능
```js
app.get('/', (req, res, next) => {
  if (!someCondition) {
    next() // 요청을 처리를 하지 않고 다른 핸들러로 넘김
  } else {
    res.send('hello')
  }
})
```

## Custom 404 page
```js
app.use((req, res, next) => {
  res.render('404.ejs')
})
```
서버의 마지막 단에 위와 같은 코드를 작성하게 되면 모든 코드가 실행 된 후 최종으로 도달하기 때문에 아무 경로를 거치지 않는 주소값이 된다.  
따라서 404page를 custom하여 이쁜 404page를 표출 할 수 있다.  

## 에러처리
```js
app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
```
에러처리는 웹서버에서 어떠한 에러가 났을 때 슬랙에 연동하여 에러를 바로 처리 할 수 있독록 만들 수 있다.  
Bugsnag을 이용하면 에러가 난 횟수를 그래프로 표출하고 어떠한 에러가 났는지 로그기록을 볼 수 있다.(에러처리 미들웨어)
에러처리 미들웨어는 서비스 하는 미들웨어가 있기때문에 직접 만들 일은 거의 없다.  
에러처리 미들웨어는 Sentry, Bugsnag 등이 있다.  

- - -
# cookie

## 쿠키의 필요성
개별 클라이언트의 여러 요청에 걸친 정보의 유지
- 장바구니
- 로그인/ 로그아웃
- 방문 기록
- ...

## HTTP Cookie
- 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보(서버의 데이터가 웹브라우저에 저장)
- 웹브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있음
- 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공

## 쿠키 전송 절차
1. 서버는 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다.(Set-Cookie 헤더)
```js
HTTP/1.1 200 OK
Set-Cookie: cookieName=cookieValue; Secure; Max-Age=60000
...
```
2. 브라우저는 같은 서버에 요청이 일어날 때마다 해당 정보를 요청에 같이 실어서 서버에 보낸다. (Cookie 헤더)
```js
GET / HTTP/1.1
Cookie: cookieName=cookieValue; anotherName=anotherValue
...
```

## Set-Cookie Options
Expires(시간), Max-Age(유효기간)  
-  쿠키의 지속 시간 설정  

Secure
- HTTPS를 통해서만 쿠키가 전송되도록 설정

HttpOnly
- 자바스크립트에서 쿠키를 읽지 못하도록 설정

Domain, Path
- 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한)
- 쿠키를 보낼 때 원하는 도메인에만 전송이 가능하게 설정

## Express + Cookie
쿠키 읽기 - req.cookies
- 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨 (cookie-parser 미들웨어 필요)
- bodyparser처럼 객체로 변환해줌

쿠키 쓰기 - res.cookie(name, value)
- 쿠키의 생성 혹은 수정
- 응답을 보내기 전에 설정을 하면 응답을 보낼 때 쿠키의 생성 혹은 수정을 가능케 함.

### httpOnly 쿠키
httpOnly를 사용하게 되면 보안에 좋다.  
쿠키는 httpOnly를 사용하여 자바스크립트에서 사용하지 않는 것이 좋다.  

### maxAge 쿠키
maxAge 쿠키는 10분후 로그아웃 셋팅 등 시간 제한을 두고 쿠키의 생애를 설정 할 수 있다.  

### path 쿠키
특정 경로와 특정 도메인에서만 사용 가능하도록 설정 가능하다.  

### 여러가지 쿠키 설정
```js
// 여러 옵션을 한꺼번에 지정할 수도 있습니다.
app.get('/multiple-options', (req, res) => {
  res.cookie('multipleOption', 'value', {
    secure: true,
    httpOnly: true,
    maxAge: 5000
  })
  res.redirect('/')
})
```
위 코드와 같이 한번에 쿠키를 사용하도록 설정 할 수 있다.  

## JavaScript + Cookie
- 자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. (XSS방법의 해킹으로부터 방어)
- 자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice

## 쿠키의 한계점
- US-ASCII 밖에 저장하지 못함. 보통 percent encoding을 사용
- 4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못함
- 브라우저에 저장됨. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절 (크롬에 저장된 쿠키는 파이어폭스에서 사용이 안된다.)
- 쿠키를 이용하여 장바구니를 구현한 사이트는 브라우저가 변경되면 보이지 않게 된다. 하지만 요즘 사이트는 다른 방법으로 구현을 하고 있다.  
- 웹브라우저와 모바일장치에서 사용하게 되는 프로그램은 쿠키를 사용하지 않는 것이 좋다.  

- - -
# Session
실질적 의미
- 시작 조건과 종료 조건이 있는 시간, 또는 회기
- **정보 교환이 지속되는 시간**, 또는 회기

## 세션의 예
HTTP session
- 요청 - 응답

로그인 세션 (보통 운영체제에서 사용)
- 로그인 - 로그아웃

Google Analytics 세션 (페이지 사용자 수 측정)
- 페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능)
- 한 사용자가 30분 내에 중복 접속을 하면 1번 접속으로 보지만 30분 이후에 접속을 하면 다른 접속으로 간주한다.  

## 웹 서비스를 위한 세션의 구현
1. 세션이 시작(ex. 로그인)되면, 세션이 시작되었다는 사실을 쿠키에 저장
2. 세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 **<u>어딘가</u>에 저장**
3. 세션이 만료되면, 세션이 만료되었다는 사실을 쿠키에 반영
(Expire: session을 지정하면 브라우저가 갑자기 종료하게 되면 꺼지게 된다.)

## 세션 스토어(세션에 대한 정보를 저장하는 곳)
세션에 대한 정보를 저장하는 <u>어딘가</u>
- 쿠키
- 데이터베이스
- 파일
- 기타 정보를 저장할 수 있는 곳 어디든

## 세션 스토어의 선택
서비스의 요구사항에 맞춰서 적절한 저장소를 선택하면 됨
- 정보의 형태가 간단하고 자주 바뀔 일이 없으면 쿠키
- 저장해야 할 정보의 양이 많으면 데이터베이스
- 정보가 굉장히 자주 변경되면 메모리 기반 저장소

## 세션? 세션 스토어?
'세션'과 '세션 스토어'는 엄연히 다른 말이지만 혼용되는 경우가 많습니다.  
'세션에 정보를 저장한다'는 말은 '세션 스토어에 정보를 저장한다'는 말과 같은 뜻이라고 생각하면 됩니다.

## Express + Session
cookie-session (세션의 시작이 정해져있음)
- 쿠키에 모든 정보를 저장하는 세션 스토어.   
- 첫 방문시 무조건 세션 시작  

express-session
- 쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어.
- 외부 저장소에 대한 별도의 설정 필요

쿠키에 대한 자세한 옵션은 미들웨어를 생성 할 때 옵션을 설정한다.  

- - -
# 해시 함수
원본이 변형되었는지 확인 할 때 사용한다.  
같은 입력에 대해서는 같은 결과가 나오고 약간이라도 내용이 다르다면 전혀 다른 결과 값이 나온다.  

## 좋은 해시함수
1. 결과가 짧으면 좋다.  
2. 해시 충돌의 확률이 적어야한다.  

## md5 calculator
md5는 해쉬함수로 변환해주는 변환 계산기이다.  

## 서명
서명을 통한 보안
1. 조작 방지
2. 데이터의 공개를 막아주지는 않는다.  